package OmniPITR::Program::Backup::Master;
use strict;
use warnings;

use base qw( OmniPITR::Program );

use Carp;
use OmniPITR::Tools qw( :all );
use English qw( -no_match_vars );
use File::Basename;
use Sys::Hostname;
use POSIX qw( strftime );
use File::Spec;
use File::Path qw( mkpath rmtree );
use File::Copy;
use Storable;
use Getopt::Long qw( :config no_ignore_case );

sub run {
    my $self = shift;
    $self->read_state();
    $self->get_list_of_all_necessary_compressions();
    $self->choose_base_local_destinations();

    return;
}

sub choose_base_local_destinations {
    my $self = shift;

    my $base = { map { ( $_ => undef ) } @{ $self->{ 'compressions' } } };
    $self->{ 'base' } = $base;

    for my $dst ( @{ $self->{ 'destination' }->{ 'local' } } ) {
        my $type = $dst->{ 'compression' };
        next if defined $base->{ $type };
        $base->{ $type } = $dst->{ 'path' };
    }

    my @unfilled = grep { !defined $base->{ $_ } } keys %{ $base };

    return if 0 == scalar @unfilled;
    $self->log->log( 'These compression(s) were given only for remote destinations. Usually this is not desired: %s', join( ', ', @unfilled ) );

    $self->prepare_temp_directory();
    for my $type ( @unfilled ) {
        my $tmp_dir = File::Spec->catfile( $self->{ 'temp-dir' }, $type );
        mkpath( $tmp_dir );
        $base->{ $type } = $tmp_dir;
    }
    return;
}

sub DESTROY {
    my $self = shift;
    return unless $self->{ 'temp-dir-prepared' };
    rmtree( $self->{ 'temp-dir-prepared' } );
    return;
}

=head1 prepare_temp_directory()

Helper function, which builds path for temp directory, and creates it.

Path is generated by using given temp-dir, 'omnipitr-archive' name, and filename of segment.

For example, for temp-dir '/tmp' and segment being pg_xlog/000000010000000000000003, actual, used temp directory would be /tmp/omnipitr-archive/000000010000000000000003/.

=cut

sub prepare_temp_directory {
    my $self = shift;
    my $full_temp_dir = File::Spec->catfile( $self->{ 'temp-dir' }, basename( $PROGRAM_NAME ) );
    mkpath( $full_temp_dir );
    $self->{ 'temp-dir' }          = $full_temp_dir;
    $self->{ 'temp-dir-prepared' } = $full_temp_dir;
    return;
}

=head1 read_state()

Helper function to read state from state file.

Name of state file is the same as filename of WAL segment being archived, but it is in state-dir.

=cut

sub read_state {
    my $self = shift;
    $self->{ 'state' } = {};

    return unless $self->{ 'state-dir' };

    $self->{ 'state-file' } = File::Spec->catfile( $self->{ 'state-dir' }, 'omnipitr-backup-master.state' );
    return unless -f $self->{ 'state-file' };
    $self->{ 'state' } = retrieve( $self->{ 'state-file' } );
    return;
}

=head1 save_state()

Helper function to save state to state-file.

=cut

sub save_state {
    my $self = shift;

    return unless $self->{ 'state-file' };

    store( $self->{ 'state' }, $self->{ 'state-file' } );

    return;
}

=head1 get_list_of_all_necessary_compressions()

Scans list of destinations, and gathers list of all compressions that have to be made.

This is to be able to compress file only once even when having multiple destinations that require compressed format.

=cut

sub get_list_of_all_necessary_compressions {
    my $self = shift;

    my %compression = ();

    for my $dst_type ( qw( local remote ) ) {
        next unless my $dsts = $self->{ 'destination' }->{ $dst_type };
        for my $destination ( @{ $dsts } ) {
            $compression{ $destination->{ 'compression' } } = 1;
        }
    }
    $self->{ 'compressions' } = [ keys %compression ];
    return;
}

=head1 read_args()

Function which does all the parsing, and transformation of command line arguments.

It also verified base facts about passed WAL segment name, but all other validations, are being done in separate function: L<validate_args()>.

=cut

sub read_args {
    my $self = shift;

    my @argv_copy = @ARGV;

    my %args = (
        'data-dir'          => '.',
        'temp-dir'          => $ENV{ 'TMPDIR' } || '/tmp',
        'gzip-path'         => 'gzip',
        'bzip2-path'        => 'bzip2',
        'lzma-path'         => 'lzma',
        'tar-path'          => 'tar',
        'nice-path'         => 'nice',
        'psql-path'         => 'psql',
        'rsync-path'        => 'rsync',
        'database'          => 'postgres',
        'filename-template' => '__HOSTNAME__-__FILETYPE__-^Y-^m-^d.tar__CEXT__',
    );

    croak( 'Error while reading command line arguments. Please check documentation in doc/omnipitr-master-backup.pod' )
        unless GetOptions(
        \%args,
        'data-dir|D=s',
        'database|d=s',
        'host|h=s',
        'port|p=i',
        'username|U=s',
        'xlogs|x=s',
        'dst-local|dl=s@',
        'dst-remote|dr=s@',
        'temp-dir|t=s',
        'log|l=s',
        'filename-template|f=s',
        'pid-file',
        'verbose|v=s',
        'gzip-path|gp=s',
        'bzip2-path|bp=s',
        'lzma-path|lp=s',
        'nice-path|np=s',
        'psql-path|pp=s',
        'tar-path|tp=s',
        'rsync-path|rp=s',
        'state-dir|s=s',
        );

    croak( '--log was not provided - cannot continue.' ) unless $args{ 'log' };
    for my $key ( qw( log filename-template ) ) {
        $args{ $key } =~ tr/^/%/;
    }

    for my $key ( grep { !/^dst-(?:local|remote)$/ } keys %args ) {
        $self->{ $key } = $args{ $key };
    }

    for my $type ( qw( local remote ) ) {
        my $D = [];
        $self->{ 'destination' }->{ $type } = $D;

        next unless defined $args{ 'dst-' . $type };

        my %temp_for_uniq = ();
        my @items = grep { !$temp_for_uniq{ $_ }++ } @{ $args{ 'dst-' . $type } };

        for my $item ( @items ) {
            my $current = { 'compression' => 'none', };
            if ( $item =~ s/\A(gzip|bzip2|lzma)=// ) {
                $current->{ 'compression' } = $1;
            }
            $current->{ 'path' } = $item;
            push @{ $D }, $current;
        }
    }

    $self->{ 'filename-template' } = strftime( $self->{ 'filename-template' }, localtime time() );
    $self->{ 'filename-template' } =~ s/__HOSTNAME__/hostname()/ge;

    # We do it here so it will actually work for reporing problems in validation
    $self->{ 'log_template' } = $args{ 'log' };
    $self->{ 'log' }          = OmniPITR::Log->new( $self->{ 'log_template' } );

    $self->log->log( 'Called with parameters: %s', join( ' ', @argv_copy ) ) if $self->verbose;

    return;
}

=head1 validate_args()

Does all necessary validation of given command line arguments.

One exception is for compression programs paths - technically, it could be validated in here, but benefit would be pretty limited, and code to do so relatively complex, as compression program path
might, but doesn't have to be actual file path - it might be just program name (without path), which is the default.

=cut

sub validate_args {
    my $self = shift;

    my $dst_count = scalar( @{ $self->{ 'destination' }->{ 'local' } } ) + scalar( @{ $self->{ 'destination' }->{ 'remote' } } );
    $self->log->fatal( "No --dst-* has been provided!" ) if 0 == $dst_count;

    if ( 1 < $dst_count ) {
        $self->log->fatal( "More than 1 --dst-* has been provided, but no --state-dir!" ) if !$self->{ 'state-dir' };
        $self->log->fatal( "Given --state-dir (%s) does not exist",     $self->{ 'state-dir' } ) unless -e $self->{ 'state-dir' };
        $self->log->fatal( "Given --state-dir (%s) is not a directory", $self->{ 'state-dir' } ) unless -d $self->{ 'state-dir' };
        $self->log->fatal( "Given --state-dir (%s) is not writable",    $self->{ 'state-dir' } ) unless -w $self->{ 'state-dir' };
    }

    $self->log->fatal( "Filename template does not contain __FILETYPE__ placeholder!" ) unless $self->{ 'filename-template' } =~ /__FILETYPE__/;
    $self->log->fatal( "Filename template cannot contain / or \\ characters!" ) if $self->{ 'filename-template' } =~ m{[/\\]};

    return;
}

1;
