package OmniPITR::Program;
use strict;
use warnings;
use English qw( -no_match_vars );

use OmniPITR::Log;
use OmniPITR::Pidfile;
use OmniPITR::Tools qw( run_command );
use File::Basename;
use File::Path qw( mkpath rmtree );
use File::Spec;
use Carp;

our $VERSION = '0.4.0';

=head1 new()

Object contstructor.

Since all OmniPITR programs are based on object, and they start with
doing the same things (namely reading and validating command line
arguments) - this is wrapped in here, to avoid code duplication.

Constructor also handles pid file creation, in case it was requested.

=cut

sub new {
    my $class = shift;
    my $self = bless {}, $class;
    $self->check_debug();
    $self->read_args();
    $self->validate_args();
    $self->{ 'pid-file' } = OmniPITR::Pidfile->new( 'pidfile' => $self->{ 'pid-file' } ) if $self->{ 'pid-file' };

    return $self;
}

=head1 check_debug()

Internal method providing --debug option handling to every omnipitr program.

If *first* argument to omnipitr program it will print to stderr all arguments, and environment variables.

=cut

sub check_debug {
    my $self = shift;
    return if 0 == scalar @ARGV;
    return unless '--debug' eq $ARGV[ 0 ];

    warn "DEBUG INFORMATION:\n";
    for my $key ( sort keys %ENV ) {
        warn sprintf( "ENV: '%s' => '%s'\n", $key, $ENV{ $key } );
    }
    warn "Command line arguments: [" . join( "] , [", @ARGV ) . "]\n";
    shift @ARGV;

    return;
}

=head1 run()

Just a stub method, that has to be overriden in subclasses.

=cut

sub run {
    my $self = shift;
    croak( "run() method in OmniPITR::Program was not overridden!" );
}

=head1 verbose()

Shortcut to make code a bit nicer.

Returns values of (command line given) verbose switch.

=cut

sub verbose { return shift->{ 'verbose' }; }

=head1 log()

Shortcut to make code a bit nicer.

Returns logger object.

=cut

sub log { return shift->{ 'log' }; }

=head1 prepare_temp_directory()

Helper function, which builds path for temp directory, and creates it.

Path is generated by using given temp-dir and 'omnipitr-backup-master' named.

For example, for temp-dir '/tmp' used temp directory would be /tmp/omnipitr-backup-master.

If any arguments are passed - they are treated as subdirectories. For example, in above example, if ("xxx", "yyy") was passed, generated directory would be /tmp/omnipitr-backup-master/xxx/yyy.
=cut

sub prepare_temp_directory {
    my $self = shift;
    return if $self->{ 'temp-dir-prepared' };
    my @sub_elements = @_;
    my $full_temp_dir = File::Spec->catfile( $self->{ 'temp-dir' }, basename( $PROGRAM_NAME ), @sub_elements );
    mkpath( $full_temp_dir );
    $self->{ 'temp-dir' }          = $full_temp_dir;
    $self->{ 'temp-dir-prepared' } = 1;
    return;
}

=head1 temp_file()

Returns full path to temp file. Name of the file is passed as argument, temp directory is created (if needed) and full path is returned.

=cut

sub temp_file {
    my $self     = shift;
    my $filename = shift;
    $self->prepare_temp_directory;
    return File::Spec->catfile( $self->{ 'temp-dir' }, $filename );
}

=head1 DESTROY()

Destructor for object - removes temp directory on program exit.

=cut

sub DESTROY {
    my $self = shift;
    if ( $self->{ 'temp-dir-prepared' } ) {
        rmtree( [ $self->{ 'temp-dir' } ], 0 );
        delete $self->{ 'temp-dir-prepared' };
    }
    return;
}

=head1 get_list_of_all_necessary_compressions()

Scans list of destinations, and gathers list of all compressions that have to be made.

This is to be able to compress file only once even when having multiple destinations that require compressed format.

This function is used by all programs that need to compress "stuff" - L<omnipitr-archive>, L<omnipitr-backup-master> and L<omnipitr-backup-slave>.

=cut

sub get_list_of_all_necessary_compressions {
    my $self = shift;

    croak 'get_list_of_all_necessary_compressions() method called, but there are no destinations?!' unless $self->{ 'destination' };

    my %compression = ();

    for my $dst_type ( qw( local remote ) ) {
        next unless my $dsts = $self->{ 'destination' }->{ $dst_type };
        for my $destination ( @{ $dsts } ) {
            $compression{ $destination->{ 'compression' } } = 1;
        }
    }

    $self->{ 'compressions' } = [ keys %compression ];

    return;
}

=head1 get_control_data()

Calls pg_controldata, and parses its output.

Verifies that output contains 2 critical pieces of information:

=over

=item * Latest checkpoint's REDO location

=item * Latest checkpoint's TimeLineID

=back

=cut

sub get_control_data {
    my $self         = shift;
    my $control_data = {};

    my $handle;
    if (   ( !defined $self->{ 'error-pgcontroldata' } )
        || ( 'break' eq $self->{ 'error-pgcontroldata' } ) )
    {
        $handle = sub {
            $self->log->fatal( @_ );
        };
    }
    elsif ( 'ignore' eq $self->{ 'error-pgcontroldata' } ) {
        $handle = sub {
            $self->log->error( @_ );
        };
    }
    else {
        $handle = sub {
            $self->log->error( @_ );
            sleep 600 while 1;
        };
    }

    $self->prepare_temp_directory();

    my $response = run_command( $self->{ 'temp-dir' }, $self->{ 'pgcontroldata-path' }, $self->{ 'data-dir' } );
    if ( $response->{ 'error_code' } ) {
        $handle->( 'Error while getting pg_controldata for %s: %s', $self->{ 'data-dir' }, $response );
        return undef;
    }

    my @lines = split( /\s*\n/, $response->{ 'stdout' } );
    for my $line ( @lines ) {
        unless ( $line =~ m{\A([^:]+):\s*(.*)\z} ) {
            $handle->( 'Pg_controldata for %s contained unparseable line: [%s]. Full response: %s', $self->{ 'data-dir' }, $line, $response );
            return undef;
        }
        $control_data->{ $1 } = $2;
    }

    unless ( $control_data->{ "Latest checkpoint's REDO location" } ) {
        $handle->( 'Pg_controldata for %s did not contain latest checkpoint redo location. Full response: %s', $self->{ 'data-dir' }, $response );
        return undef;
    }
    unless ( $control_data->{ "Latest checkpoint's TimeLineID" } ) {
        $handle->( 'Pg_controldata for %s did not contain latest checkpoint timeline ID. Full response: %s', $self->{ 'data-dir' }, $response );
        return undef;
    }

    return $control_data;
}

=head1 psql()

Runs given query via psql - assumes there is $self->{'psql-path'}.

Uses also:

=over

=item * username

=item * database

=item * port

=item * host

=item

optional keys from $self.

On first run it will cache psql call arguments, so if you'd change them on
subsequent calls, you have to delete $self->{'psql'}.

In case of errors, it raises fatal error.

Otherwise returns stdout of the psql.

=cut

sub psql {
    my $self = shift;
    my $query = shift;

    unless ( $self->{'psql'} ) {
        my @psql = ();
        push @psql, $self->{ 'psql-path' };
        push @psql, '-qAtX';
        push @psql, ( '-U', $self->{ 'username' } ) if $self->{ 'username' };
        push @psql, ( '-d', $self->{ 'database' } ) if $self->{ 'database' };
        push @psql, ( '-h', $self->{ 'host' } )     if $self->{ 'host' };
        push @psql, ( '-p', $self->{ 'port' } )     if $self->{ 'port' };
        push @psql, '-c';
        $self->{'psql'} = \@psql;
    }

    $self->prepare_temp_directory();

    my @command = ( @{ $self->{ 'psql' } }, $query );

    $self->log->time_start( $query ) if $self->verbose;
    my $status = run_command( $self->{ 'temp-dir' }, @command );
    $self->log->time_finish( $query ) if $self->verbose;

    $self->log->fatal( 'Running [%s] via psql failed: %s', $query, $status ) if $status->{ 'error_code' };

    return $status->{ 'stdout' };
}

=head1 find_tablespaces()

Helper function.  Takes no arguments.  Uses pg_tblspc directory and returns
a hashref of the physical locations of tablespaces.
Keys in the hashref are tablespace OIDs (link names in pg_tblspc). Values
are hashrefs with two keys:

=over

=item * pg_visible - what is the path to tablespace that PostgreSQL sees

=item * real_path - what is the real absolute path to tablespace directory

=back

The two can be different in case tablespace got moved and symlinked back to
original location, or if tablespace path itself contains symlinks.

=cut

sub get_tablespaces {
    my $self = shift;

    # Identify any tablespaces and get those
    my $tablespace_dir = File::Spec->catfile( $self->{ 'data-dir' }, "pg_tblspc" );
    my %tablespaces;

    return unless -e $tablespace_dir;

    my @pgfiles;
    opendir( my $dh, $tablespace_dir ) or $self->log->fatal( "Unable to open tablespace directory $tablespace_dir" );

    # Push onto our list the locations that are pointed to by the pg_tblspc symlinks
    foreach my $filename ( readdir $dh ) {
        next if $filename !~ /^\d+$/;    # Filename should be all numeric
        my $full_name = File::Spec->catfile( $tablespace_dir, $filename );
        next if !-l $full_name;          # It should be a symbolic link
        my $pg_visible = readlink $full_name;
        my $real_path = Cwd::abs_path( $full_name );
        $tablespaces{ $filename } = {
            'pg_visible' => $pg_visible,
            'real_path' => $real_path,
        };
    }
    closedir $dh;

    return \%tablespaces;
}

1;

